#![allow(rust_2018_idioms)]

use crate::ast;
use crate::ast::*;
use crate::ir::*;
use crate::MathOperator;
use std::str::FromStr;
use nan_preserving_float::F64;

grammar;

Spanned<Rule>: Spanned<Rule> =
    <l:@L> <rule:Rule> <r:@R> => rule.spanned(l, r);

pub Module: Module<'input> = {
    (<ModifiedFunction*>) => Module::new(<>)
}

ModifiedFunction: Function<'input> = {
    "export" <Function> => <>.exported(),
    <Function>
}

Function: Function<'input> = {
    "def" <name:Identifier> <args:Parameters> "->" <ty:Type> <body:Block> => Function::new(name, args, ty, body),
    "def" <name:Identifier> <args:Parameters> <body:Block> => Function::new(name, args, Type::Void, body)
}

Parameters: Parameters<'input> = {
    "(" <Parameter> <("," <Parameter>)*> ")" => Parameters::from_parser(<>),
    "(" ")" => Parameters::empty()
}

Parameter: Parameter<'input> = {
    <Identifier> ":" <Type> => Parameter::new(<>)
}

Type: Type = {
    "i32" => Type::i32(),
    "i64" => Type::i64(),
    "u32" => Type::u32(),
    "u64" => Type::u64(),
    "f32" => Type::f32(),
    "f64" => Type::f64(),
}

Block: Block<'input> = {
    "{" <(<Expression>)*> "}" => Block::new(<>)
}

Expression: Expression<'input> = {
    <Expression3>
}

Expression1: Expression<'input> = {
    <Identifier> => Expression::VariableAccess(<>),
    <I32>,
    <F64>
}

Expression2: Expression<'input> = {
    <Expression1>,
    <lhs:Expression2> "*" <rhs:Expression1> => Expression::Binary(MathOperator::Mul, Box::new(BinaryExpression::new(lhs, rhs))),
    <lhs:Expression2> "/" <rhs:Expression1> => Expression::Binary(MathOperator::Div, Box::new(BinaryExpression::new(lhs, rhs)))
}

Expression3: Expression<'input> = {
    <Expression2>,
    <lhs:Expression3> "+" <rhs:Expression2> => Expression::Binary(MathOperator::Add, Box::new(BinaryExpression::new(lhs, rhs))),
    <lhs:Expression3> "-" <rhs:Expression2> => Expression::Binary(MathOperator::Sub, Box::new(BinaryExpression::new(lhs, rhs)))
}

Identifier: Identifier<'input> = <id: Spanned<RawIdentifier>> => id;
RawIdentifier: RawIdentifier<'input> = <id: r"[a-zA-Z_][a-zA-Z0-9_]*"> => ident(id);

I32: Expression<'input> = <r"[0-9]+"> => Expression::Const(ast::ConstExpression::Integer(FromStr::from_str(<>).unwrap()));
F64: Expression<'input> = <r"[0-9]+.[0-9]+"> => Expression::Const(ast::ConstExpression::Float(F64::from_float(FromStr::from_str(<>).unwrap())));

match {
    r"[0-9]+.[0-9]+"
} else {
    r"[0-9]+"
} else {
    _
}